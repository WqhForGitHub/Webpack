### 6.1 通过入口划分代码

  在 Webpack 中每个入口都将生成一个对应的资源文件，通过入口的配我们可以进行一些简单有效的代码拆分。

  通常 Web 应用中会有一些库和工具是不常变动的，我们可以把它们放在一个单独的入口中，由该入口产生的资源不会经常更新，从而有效地利用客户端缓存，让用户不必在每次请求页面时都重新加载。如：

```javascript
entry: {
    app: './app.js',
    lib: ['lib-a', 'lib-b', 'lib-c']
}                                                                                                                              
```

```html
<script src="dist/lib.js"></script>
<script src="dist/app.js"></script>
```



​                                                                              

                                                                                                                                                                                                                                                                                                                         ### 6.2 CommonsChunkPlugin

​     

### 6.3 optimization.SplitChunks

optimization.SplitChunks（简称 SplitChunks）是 Webpack4 为了改进 CommonsChunkPlugin 而重新设计和实现的代码分片特性。它不仅比 CommonsChunkPlugin 功能更加强大，还更简单易用。

  比如我们前面异步加载的例子，在换成 Webpack 4 的 SplitChunks 之后，就可以自动提取出 react 了。请看下面的例子：

```                                                                                                                              javascript
// webpack.config.js
module.exports = {
    entry: './foo.js',
    output: {
        filename: 'foo.js',
        publicPath: '/dist/'
    },
    mode: 'development',
    optimization: {                                                                           
        splitChunks: {
            chunks: 'all'
        }
    }
}
```

```javascript
// foo.js
import React from 'react';
import('./bar.js');
document.write('foo.js', React.version);
```

```javascript
// bar.js
import React from 'react';
console.log('bar.js', React.version);
```

1. 从命令式到声明式

   以下是 SplitChunks 的默认配置。

   * 提取后的 chunk 可被共享或者来自 node_modules 目录。这一条很容易理解，被多次引用或处于 node_modules 中的模块更倾向于是通用模块，比较适合被提取出来。
   * 提取后的 JavaScript chunk 体积大于 20KB（压缩和 gzip 之前），CSS chunk 体积大于 50KB。这个也比较容易理解，如果提取后的资源体积大小，那么                    带来的优化效果也比较一般。
   * 在按需加载过程中，并行请求的资源最大值小于等于30。按需加载指的是，通过动态插入 script 标签的方式加载脚本。我们一般不希望同时加载过多的资源，因为每一个请求都要带来建立和释放链接的成本，因此提取规则只在并行请求不多的时候生效。
   * 在首次加载时，并行请求的资源数量最大值小于等于 30。上一条类似，但因为页面首次加载时往往对性能的要求更高，我们可将它手动设置为更低。    

   通过前面的例子我们可以进一步解释这些条件。在从 foo.js 和 bar.js 提取 react 前，系统会对这些条件一一进行验证，只有满足了所有条件之后 react 才会被提取出来。下面我们进行一下比对：

   * react 属于 node_modules 目录下的模块。
   * react 的体积大于 20KB。
   * 按需加载时的并行请求数量为 1，为 0.foo.js。
   * 首次加载时的并行请求数量为 2，为 foo.js 和 vendors-main.foo.js。之所以 vendors-main.foo.js 不算在第 3 条是因为它需要被添加在 HTML 的 script 标签中，在页面初始化的时候就会进行加载。

2. 默认的异步提取

   前面我们对 SplitChunks 添加了一个 chunks: all 的配置，这是为了提取 foo.js 和 bar.js 的公共模块。实际上 SplitChunks 不配置该项也能生效，但仅仅针对异步资源。请看下面的例子：

   ```javascript
   // webpack.config.js
   module.exports = {
       entry: './foo.js',
       output: {
           filename: 'foo.js',
           publicPath: '/dist/'
       },
       mode: 'development'
   };
   ```

   ```javascript
   // foo.js
   import('./bar.js');
   console.log('foo.js');
   ```

   ```javascript
   // bar.js
   import lodash from 'lodash';
   console.log(lodash.flatten([1, [2, 3]]));
   ```



3. 配置

   为了更好地了解 SplitChunks 是怎么工作的，我们来看一下它的默认配置。

   ```javascript
   splitChunks: {
       chunks: "async",
       minSize: 20000,
       minRemainingSize: 0,
       minChunks: 1,
       maxAsyncRequests: 30,
       maxInitialRequests: 30,
       enforceSizeThreshold: 50000,
       cacheGroups: {
           vendors: {
               test: /[\\/]node_modules[\\/]/,
               priority: -10
           },
           default: {
           	minChunks: 2,
               priority: -20,
               reuseExistingChunk: true
           }
       }
   }
   ```

   ​                                                                            

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       