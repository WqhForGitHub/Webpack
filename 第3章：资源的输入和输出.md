context 可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。请看下面的例子：

```javascript
module.exports = {
  context: path.join(__dirname, '/src/scripts'),
  entry: './index.js'
}
```

配置 context 的主要目的是让 entry 的编写更加简洁，尤其是在多入口的情况下。context 可以省略，默认值为当前工程的根目录。



1. 字符串类型入口

直接传入文件路径：

```javascript
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js'
  },
  mode: 'development'
}
```



2. 数组类型入口

传入一个数组的作用是将多个资源预先合并，这样 Webpack 在打包时会将数组中的最后一个元素作为实际的入口路径。如：

```javascript
module.exports = {
  entry: ['babel-polyfill', './src/index.js']
}
```

 上面的配置等同于：

```javascript
module.exports = {
  entry: './src/index.js'
};

// index.js
import 'babel-polyfill';
```



3. 对象类型入口

 如果想要定义多入口，则必须使用对象的形式。对象的属性名是 chunk name，属性值是入口路径。如：

```javascript
module.exports = {
  entry: {
    index: './src/index.js',
    lib: './src/lib.js'
  }
}
```



entry 对象的属性值也可以为字符串或数组。如：

```javascript
module.exports = {
  entry: {
    index: ['babel-polyfill', './src/index.js'],
    lib: './src/lib.js'
  }
}
```

在使用字符串或数组定义单入口时，我们没有办法更改 chunk name，只能用默认的 main。在使用对象时来定义多入口时，则必须为每一个入口定义 chunk name。                      



4. 函数类型入口

我们也可以使用匿名函数来定义入口。其实非常简单，只要使匿名函数的返回值为上面介绍的任何配置形式即可，如：

```javascript
module.exports = {
  entry: () => './src/index.js'
}
```

```javascript
module.exports = {
  entry: () => ({
    index: ['babel-polyfill', './src/index.js'],
    lib: './src/lib.js'
  })
}
```



